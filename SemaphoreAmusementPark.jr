import edu.ucdavis.jr.JR;
import edu.ucdavis.jr.QuiescenceRegistrationException;

import java.util.Queue;
import java.util.ArrayList;
import java.util.LinkedList;

import java.util.concurrent.ThreadLocalRandom;

public class SemaphoreAmusementPark {

    // Ride duration in seconds
    // private static final int RIDE_DURATION_SECONDS = 30;

    // Lap duration in seconds (5 laps = 1 ride)
    private static final int LAP_DURATION_SECONDS = 1;

    // Program duration in seconds
    private static final int PROGRAM_DURATION_SECONDS = 30;

    // Maximum time in milliseconds that is randomly added to base time when riding the rollecoaster
    private static final int RANDOM_ADDITIONNAL_TIME_MILLIS = 5;

    // Rollercoaster maximum capacity
    private static final int C = 16;

    // Total number of people in line and on the rollercoaster
    private static final int N = 50;

    // Mutex
    private static final sem mutex = 1;
    
    // Counting semaphore used by people to check if the car has space available (FULL)
    private static final sem canGetIn = C;  // Allow access until the car is full

    // Counting semaphore used by people to check if the car is empty (EMPTY)
    private static final sem canGetOut = 0;  // Allow access until the car is full

    // First-in-first-out queue representing people(id) waiting in line for the rollercoaster
    private static Queue<Integer> waitingLine = new LinkedList<Integer>();
    // Initialize N amount of people in the waiting line
    static {
        for (int id = 0; id < N; ++id) {
            waitingLine.add(id);
        }
    }
    
    // Array containing the IDs of the people in the rollercoaster car (empty at first)
    private static ArrayList<Integer> car = new ArrayList<Integer>(C);

    // Conditional variable for the rollercoaster
    private static final sem canStart = 0;
    


    // Rollercoaster process
    private static process RollerCoaster {
        // It goes on and on
        while (true) {
            do5LapsAndStop();
        }
    }

    // Person process
    private static process Person((int id = 0; id < N; ++id)) {
        // Those guys never stop !
        
        while (true) {
            //System.out.println("ABOUT TO GET IN THE CAR IF I CAN");
            getInCarIfPossible();
            //System.out.println("GETTING OUT: RIDE SHOULD BE OVER");
            getOutOfCarIfPossible();
        }
    }

    private static void getInCarIfPossible() {
        P(canGetIn);
        P(mutex);
        car.add(waitingLine.poll());
        System.out.println("Someone got in the car. Size = " + car.size());
        V(mutex);
        if (car.size() == C) {
            V(canStart);
        }
    }

    private static void getOutOfCarIfPossible() {
        P(canGetOut);
        P(mutex);
        waitingLine.add(car.remove(0));
        System.out.println("Someone got out of the car. Size = " + car.size());
        V(mutex);
        // if (car.size() == 0)
        //     System.out.println("Car is now empty. People will now be able to get in.");
        V(canGetIn);
    }

    private static void do5LapsAndStop() {
        P(canStart);
        System.out.println("Ride is about to start (the car is full!). " + waitingLine.size() 
            + " people are still waiting in line, and the next one to get in will be #" + waitingLine.element() + ".");
        P(mutex);
        System.out.println("Ride is starting! WOOOO!! First passenger: #" + car.get(0) + " Last passenger: #" + car.get(car.size()-1));
        wait(5 * LAP_DURATION_SECONDS * 1000);
        System.out.println("Ride has stopped.");
        V(mutex);
        System.out.println("Everyone is getting out of the car (and back in line for more).");
        for (int i = 0; i < C; ++i) {
            V(canGetOut);
        }
        
    }
    
    // Process that stops the program after a certain time
    private static process EndProgram {
        wait(PROGRAM_DURATION_SECONDS * 1000);
        JR.exit(1);
    }
    
    // Encapsulates the waiting process
    private static void wait(int baseTimeMillis) {
        try {
            // Wait for specified time plus some more milliseconds
            Thread.sleep(baseTimeMillis + ThreadLocalRandom.current().nextInt(RANDOM_ADDITIONNAL_TIME_MILLIS + 1));
        } catch (InterruptedException e) {
            System.err.println("WAITING INTERRUPTED !");
            JR.exit(1);
        }
    }
    
    // Called when the program is in trouble !
    public static op void unexpectedEnd() {
        System.err.println("PROCESSES ARE EITHER IN A DEADLOCK OR ALL DEAD!!!");
    }

    // Program entry point
    public static void main(String[] args) {
        try {
            JR.registerQuiescenceAction(unexpectedEnd);
        } catch (QuiescenceRegistrationException e) {
            e.printStackTrace();
        }
    }
}
